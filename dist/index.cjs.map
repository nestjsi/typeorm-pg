{
  "version": 3,
  "sources": ["../src/index.ts", "../src/class/safe-naming-strategy.class.ts", "../src/constant/column.const.ts", "../src/util/crypt-sha1.func.ts", "../src/util/extract-table-name.func.ts", "../src/util/camel.func.ts", "../src/util/snake.func.ts", "../src/util/safe-constraint.func.ts", "../src/util/strip-schema.func.ts", "../src/util/strip-public.func.ts", "../src/constant/options.const.ts", "../src/decorator/checks.decorator.ts", "../src/decorator/index-columns.decorator.ts", "../src/util/safe-index.func.ts", "../src/decorator/unique-columns.decorator.ts", "../src/util/safe-unique.func.ts"],
  "sourcesContent": ["export * from \"./class/safe-naming-strategy.class\";\n\nexport * from \"./constant/column.const\";\nexport * from \"./constant/options.const\";\n\nexport * from \"./decorator/checks.decorator\";\nexport * from \"./decorator/index-columns.decorator\";\nexport * from \"./decorator/unique-columns.decorator\";\n\nexport * from \"./util/crypt-sha1.func\";\nexport * from \"./util/extract-table-name.func\";\nexport * from \"./util/safe-constraint.func\";\nexport * from \"./util/safe-index.func\";\nexport * from \"./util/safe-unique.func\";\nexport * from \"./util/strip-public.func\";\nexport * from \"./util/strip-schema.func\";\n", "import { DefaultNamingStrategy, NamingStrategyInterface, Table } from \"typeorm\";\n\nimport { PGSQL_MAX_IDENTIFIER_LENGTH } from \"../constant/column.const\";\n\nimport { cryptSha1 } from \"../util/crypt-sha1.func\";\nimport { extractTableName } from \"../util/extract-table-name.func\";\nimport { safeConstraint } from \"../util/safe-constraint.func\";\nimport { stripPublic } from \"../util/strip-public.func\";\n\nexport class SafeNamingStrategy extends DefaultNamingStrategy implements NamingStrategyInterface {\n  public name: string = \"SafeNamingStrategy\";\n\n  /**\n   * @name indexName\n   * @param {Table|string} [tableOrName]\n   * @param {string[]} [columnNames]\n   * @param {string=} [where]\n   * @param {string=} [nameStartsWith=\"IDX\"]\n   * @param {boolean} [stripPublicSchemaName=true]\n   * @param {boolean=} [stripPathAndTableAttempt=true]\n   * @returns {string}\n   */\n  public indexName(\n    tableOrName: Table | string,\n    columnNames: string[],\n    where?: string,\n    nameStartsWith: string = \"IDX\",\n    stripPublicSchemaName: boolean = true,\n    stripPathAndTableAttempt: boolean = true,\n  ): string {\n    let tableName = stripPublic(extractTableName(tableOrName), stripPublicSchemaName);\n    const maxLength = PGSQL_MAX_IDENTIFIER_LENGTH - nameStartsWith.length;\n    const columns = columnNames.map((name) => stripPublic(name, stripPublicSchemaName)).join(\"_\");\n    const indexName = `${nameStartsWith}__${tableName}__${columns}`;\n    if (indexName.length > maxLength) {\n      if (stripPathAndTableAttempt) {\n        const indexNameAttempt = `${nameStartsWith}__${columns}`;\n        if (indexNameAttempt.length <= maxLength) {\n          return safeConstraint(indexNameAttempt);\n        }\n      }\n      return safeConstraint(`${nameStartsWith}__${cryptSha1(indexName)}`);\n    } else {\n      return safeConstraint(indexName);\n    }\n  }\n\n  /**\n   * @foreignKeyName\n   * @param {Table|string} [tableOrName]\n   * @param {string[]} [columnNames]\n   * @param {string=} [referencedTablePath]\n   * @param {string[]=} [referencedColumnNames]\n   * @param {string=} [nameStartsWith=\"FK\"]\n   * @param {boolean=} [stripPublicSchemaName=true]\n   * @param {boolean=} [stripPathAndTableAttempt=true]\n   * @returns {string}\n   */\n  public foreignKeyName(\n    tableOrName: Table | string,\n    columnNames: string[],\n    referencedTablePath?: string,\n    referencedColumnNames?: string[],\n    nameStartsWith: string = \"FK\",\n    stripPublicSchemaName: boolean = true,\n    stripPathAndTableAttempt: boolean = true,\n  ): string {\n    const tableName = stripPublic(extractTableName(tableOrName), stripPublicSchemaName);\n    const tablePath = stripPublic(referencedTablePath || \"\", stripPublicSchemaName);\n    const foreignKeyName = columnNames.reduce(\n      (name: string, column: string) =>\n        `${stripPublic(name, stripPublicSchemaName)}__${stripPublic(column, stripPublicSchemaName)}`,\n      `${tableName}__${tablePath}`,\n    );\n    const maxLength = PGSQL_MAX_IDENTIFIER_LENGTH - nameStartsWith.length + 2;\n    if (foreignKeyName.length > maxLength) {\n      if (stripPathAndTableAttempt) {\n        const foreignKeyNameAttempt = columnNames.reduce(\n          (name: string, column: string) => `_${stripPublic(column, stripPublicSchemaName)}`,\n          \"\",\n        );\n        if (foreignKeyNameAttempt.length <= maxLength) {\n          return safeConstraint(`${nameStartsWith}_${foreignKeyNameAttempt}`);\n        }\n      }\n      return safeConstraint(`${nameStartsWith}__${cryptSha1(foreignKeyName)}`);\n    } else {\n      return safeConstraint(`${nameStartsWith}__${foreignKeyName}`);\n    }\n  }\n\n  /**\n   * @name primaryKeyName\n   * @param {Table|string} [tableOrName]\n   * @param {string[]} [columnNames]\n   * @param {string=} [nameStartsWith=\"PK\"]\n   * @param {boolean=} [stripPublicSchemaName=true]\n   * @param {boolean=} [stripPathAndTableAttempt=true]\n   * @returns {string}\n   */\n  public override primaryKeyName(\n    tableOrName: Table | string,\n    columnNames: string[],\n    nameStartsWith: string = \"PK\",\n    stripPublicSchemaName: boolean = true,\n    stripPathAndTableAttempt: boolean = true,\n  ): string {\n    let tableName = stripPublic(extractTableName(tableOrName), stripPublicSchemaName);\n    const maxLength = PGSQL_MAX_IDENTIFIER_LENGTH - nameStartsWith.length;\n    const columns = columnNames.map((name) => stripPublic(name, stripPublicSchemaName)).join(\"_\");\n    const primaryName = `${nameStartsWith}__${tableName}__${columns}`;\n    if (primaryName.length > maxLength) {\n      if (stripPathAndTableAttempt) {\n        const primaryNameAttempt = `${nameStartsWith}__${columns}`;\n        if (primaryNameAttempt.length <= maxLength) {\n          return safeConstraint(primaryNameAttempt);\n        }\n      }\n      return safeConstraint(`${nameStartsWith}__${cryptSha1(primaryName)}`);\n    } else {\n      return safeConstraint(primaryName);\n    }\n  }\n\n  /**\n   * @name relationConstraintName\n   * @param {Table|string} [tableOrName]\n   * @param {string[]} [columnNames]\n   * @param {string=} [nameStartsWith=\"REL\"]\n   * @param {boolean=} [stripPublicSchemaName=true]\n   * @param {boolean=} [stripPathAndTableAttempt=true]\n   * @returns {string}\n   */\n  public override relationConstraintName(\n    tableOrName: Table | string,\n    columnNames: string[],\n    nameStartsWith: string = \"REL\",\n    stripPublicSchemaName: boolean = true,\n    stripPathAndTableAttempt: boolean = true,\n  ): string {\n    const tableName = stripPublic(extractTableName(tableOrName), stripPublicSchemaName);\n    const maxLength = PGSQL_MAX_IDENTIFIER_LENGTH - nameStartsWith.length;\n    const columns = columnNames.map((name) => stripPublic(name, stripPublicSchemaName)).join(\"_\");\n    const relationConstraintName = `${nameStartsWith}__${tableName}__${columns}`;\n    if (relationConstraintName.length > maxLength) {\n      if (stripPathAndTableAttempt) {\n        const relationConstraintNameAttempt = `${nameStartsWith}__${columns}`;\n        if (relationConstraintNameAttempt.length <= maxLength) {\n          return safeConstraint(relationConstraintNameAttempt);\n        }\n      }\n      return safeConstraint(`${nameStartsWith}__${cryptSha1(relationConstraintName)}`);\n    } else {\n      return safeConstraint(relationConstraintName);\n    }\n  }\n}\n", "/**\n * @description PostgreSQL's Max Identifier Length\n * @type {number}\n */\nexport const PGSQL_MAX_IDENTIFIER_LENGTH = 63 as const;\n\n/**\n * @description integer\n * @type {number}\n */\nexport const PGSQL_INTEGER_MAX: number = 2147483647 as const;\n\n/**\n * @description integer\n * @type {number}\n */\nexport const PGSQL_INTEGER_MIN: number = -2147483648 as const;\n\n/**\n * @description smallint\n * @type {number}\n */\nexport const PGSQL_SMALL_INTEGER_MAX: number = 32767 as const;\n\n/**\n * @description smallint\n * @type {number}\n */\nexport const PGSQL_SMALL_INTEGER_MIN: number = -32768 as const;\n\n/**\n * @description bigint\n * @type {string}\n */\nexport const PGSQL_BIG_INTEGER_MAX: string = '9223372036854775807' as const;\n\n/**\n * @description bigint\n * @type {string}\n */\nexport const PGSQL_BIG_INTEGER_MIN: string = '-9223372036854775808' as const;\n\n/**\n * @description numeric\n * @type {string}\n */\nexport const PGSQL_NUMERIC_MAX: string = '3141592653589793238462643383279502.1618033988749894848204586834365638' as const;\n\n/**\n * @description numeric\n * @type {string}\n */\nexport const PGSQL_NUMERIC_MIN: string = '-3141592653589793238462643383279502.1618033988749894848204586834365638' as const;\n\nexport const EMAIL_LENGTH_MAX: number = 254 as const;\nexport const EMAIL_LENGTH_MIN: number = 6 as const;\n\nexport const NAME_LENGTH_MAX: number = 99 as const;\nexport const NAME_LENGTH_MIN: number = 1 as const;\n\nexport const PASSWORD_LENGTH_MAX: number = 128 as const;\nexport const PASSWORD_LENGTH_MIN: number = 5 as const;\n\nexport const ColumnOptionsExtra = {\n  comment: \"Extra data in JSON format\",\n  default: {},\n  name: \"extra\",\n  nullable: false,\n  type: \"json\",\n} as const;\n\n/**\n * Column types used for @PrimaryGeneratedColumn() decorator.\n */\nexport enum ColumnPrimaryType {\n  BigInteger = \"bigint\",\n  Decimal = \"decimal\",\n  Integer = \"integer\",\n  SmallInteger = \"smallint\",\n  UUID = \"uuid\",\n}\n\n/**\n * @description Column types for PostgreSQL\n * @link https://typeorm.io/#/entities/column-types-for-postgres\n * @link https://github.com/typeorm/typeorm/blob/master/test/functional/database-schema/column-types/postgres/column-types-postgres.ts\n */\nexport enum ColumnType {\n  BigInteger = \"bigint\",\n  Bit = \"bit\",\n  BitVarying = \"bit varying\",\n  /**\n   * @deprecated use Boolean instead\n   * @alias Boolean\n   */\n  Bool = \"bool\",\n  Boolean = \"boolean\",\n  Box = \"box\",\n  ByteHexadecimal = \"bytea\",\n  CIText = \"citext\",\n  /**\n   * @deprecated use Character instead\n   * @alias Character\n   */\n  Char = \"char\",\n  Character = \"character\",\n  CharacterVarying = \"character varying\",\n  Circle = \"circle\",\n  Cube = \"cube\",\n  Date = \"date\",\n  DateRange = \"daterange\",\n  Decimal = \"decimal\",\n  DoublePrecision = \"double precision\",\n  Enum = \"enum\",\n  Float = \"float\",\n  /**\n   * @deprecated use Real instead\n   * @alias Real\n   */\n  Float4 = \"float4\",\n  /**\n   * @deprecated use DoublePrecision instead\n   * @alias DoublePrecision\n   */\n  Float8 = \"float8\",\n  Geography = \"geography\",\n  Geometry = \"geometry\",\n  HStore = \"hstore\",\n  IPAddress = \"inet\",\n  IPCIDR = \"cidr\",\n  /**\n   * @deprecated use Integer instead\n   * @alias Integer\n   */\n  Int = \"int\",\n  /**\n   * @deprecated use SmallInt instead\n   * @alias SmallInt\n   */\n  Int2 = \"int2\",\n  /**\n   * @deprecated use Integer instead\n   * @alias Integer\n   */\n  Int4 = \"int4\",\n  Int4Range = \"int4range\",\n  /**\n   * @deprecated use BigInt instead\n   * @alias BigInt\n   */\n  Int8 = \"int8\",\n  Int8Range = \"int8range\",\n  Integer = \"integer\",\n  Interval = \"interval\",\n  JSON = \"json\",\n  JSONB = \"jsonb\",\n  LabelTrees = \"ltree\",\n  Line = \"line\",\n  LineSegment = \"lseg\",\n  MACAddress = \"macaddr\",\n  Money = \"money\",\n  NumberRange = \"numrange\",\n  /**\n   * @deprecated use Decimal instead\n   * @alias Decimal\n   */\n  Numeric = \"numeric\",\n  Path = \"path\",\n  Point = \"point\",\n  Polygon = \"polygon\",\n  Real = \"real\",\n  SmallInteger = \"smallint\",\n  /**\n   * @description Text of variable-length with limit\n   * @alias CharacterVarying\n   */\n  String = \"character varying\",\n  Text = \"text\",\n  TextSearchQuery = \"tsquery\",\n  TextSearchVector = \"tsvector\",\n  Time = \"time\",\n  TimeStamp = \"timestamp\",\n  /**\n   * @deprecated use TimeStampWithTimeZone instead\n   * @alias TimeStampWithTimeZone\n   */\n  TimeStampWithTimeZoneAbbr = \"timestamptz\",\n  TimeStampWithTimeZoneRange = \"tstzrange\",\n  TimeStampWithoutTimeZone = \"timestamp without time zone\",\n  TimeStampWithoutTimeZoneRange = \"tsrange\",\n  TimeWithTimeZoneAbbr = \"timetz\",\n  TimeWithTimeZone = \"time with time zone\",\n  TimeWithoutTimeZone = \"time without time zone\",\n  TimeStampWithTimeZone = \"timestamp with time zone\",\n  UUID = \"uuid\",\n  /**\n   * @deprecated use BitVarying instead\n   * @alias BitVarying\n   */\n  VariableBitString = \"varbit\",\n  /**\n   * @deprecated use CharacterVarying instead\n   * @alias CharacterVarying\n   */\n  VariableChar = \"varchar\",\n  XML = \"xml\",\n}\n\nexport enum ConstLength {\n  EmailMax = 254,\n  EmailMin = 6,\n  NameMax = 99,\n  NameMin = 1,\n  PassMax = 128,\n  PassMin = 5,\n}\n\nexport enum ColumnPrefix {\n  /** Unique index / constraint */\n  AltKey = \"ak\",\n  /** Check constraint */\n  Check = \"ck\",\n  /** Default constraint */\n  Default = \"df\",\n  /** Exclusion constraint */\n  Exclusion = \"ex\",\n  /** Foreign key */\n  ForeignKey = \"fk\",\n  /** Non-unique index */\n  Index = \"idx\",\n  /** Primary Key constraint */\n  PrimaryKey = \"pk\",\n  /** Relation constraint */\n  Relation = \"rel\",\n  /** Sequences */\n  Sequences = \"seq\",\n  /** Unique constraint */\n  Unique = \"uq\",\n}\n\nexport enum ColumnSuffix {\n  /** Unique index / constraint */\n  AltKey = \"AK\",\n  /** Check constraint */\n  Check = \"CK\",\n  /** Default constraint */\n  Default = \"DF\",\n  /** Exclusion constraint */\n  Exclusion = \"EX\",\n  /** Foreign key */\n  ForeignKey = \"FK\",\n  /** Non-unique index */\n  Index = \"IDX\",\n  /** Primary Key constraint */\n  PrimaryKey = \"PK\",\n  /** Relation constraint */\n  Relation = \"REL\",\n  /** Sequences */\n  Sequences = \"SEQ\",\n  /** Unique constraint */\n  Unique = \"UQ\",\n}\n", "function rawStringToBigEndian(text: string): number[] {\n  let output = Array(text.length >> 2);\n  for (let index = 0; index < output.length; index += 1) {\n    output[index] = 0;\n  }\n  for (let index = 0; index < text.length * 8; index += 8) {\n    output[index >> 5] |= (text.charCodeAt(index / 8) & 0xff) << (24 - (index % 32));\n  }\n  return output;\n}\n\nfunction bigEndianToString(text: number[]): string {\n  let output = \"\";\n  for (let index = 0; index < text.length * 32; index += 8) {\n    output += String.fromCharCode((text[index >> 5] >>> (24 - (index % 32))) & 0xff);\n  }\n  return output;\n}\n\nfunction bigEndianToSha1(bigEndianArray: number[], textLength: number) {\n  bigEndianArray[textLength >> 5] |= 0x80 << (24 - (textLength % 32));\n  bigEndianArray[(((textLength + 64) >> 9) << 4) + 15] = textLength;\n  const word = Array(80);\n  let alpha = 1732584193;\n  let beta = -271733879;\n  let gamma = -1732584194;\n  let delta = 271733878;\n  let epsilon = -1009589776;\n  for (let index = 0; index < bigEndianArray.length; index += 16) {\n    const originalAlpha = alpha;\n    const originalBeta = beta;\n    const originalGamma = gamma;\n    const originalDelta = delta;\n    const originalEpsilon = epsilon;\n    for (let dyadic = 0; dyadic < 80; dyadic += 1) {\n      if (dyadic < 16) {\n        word[dyadic] = bigEndianArray[index + dyadic];\n      } else {\n        word[dyadic] = bitwiseRotateToLeft(\n          word[dyadic - 3] ^ word[dyadic - 8] ^ word[dyadic - 14] ^ word[dyadic - 16],\n          1,\n        );\n      }\n      const triplet = addSafe(\n        addSafe(bitwiseRotateToLeft(alpha, 5), sha1Triplet(dyadic, beta, gamma, delta)),\n        addSafe(addSafe(epsilon, word[dyadic]), sha1AdditiveConstantForCurrentIteration(dyadic)),\n      );\n      epsilon = delta;\n      delta = gamma;\n      gamma = bitwiseRotateToLeft(beta, 30);\n      beta = alpha;\n      alpha = triplet;\n    }\n    alpha = addSafe(alpha, originalAlpha);\n    beta = addSafe(beta, originalBeta);\n    gamma = addSafe(gamma, originalGamma);\n    delta = addSafe(delta, originalDelta);\n    epsilon = addSafe(epsilon, originalEpsilon);\n  }\n  return Array(alpha, beta, gamma, delta, epsilon);\n}\n\nfunction sha1Triplet(triplet: number, alpha: number, beta: number, gamma: number) {\n  if (triplet < 20) {\n    return (alpha & beta) | (~alpha & gamma);\n  }\n  if (triplet < 40) {\n    return alpha ^ beta ^ gamma;\n  }\n  if (triplet < 60) {\n    return (alpha & beta) | (alpha & gamma) | (beta & gamma);\n  }\n  return alpha ^ beta ^ gamma;\n}\n\nfunction sha1AdditiveConstantForCurrentIteration(aConstant: number) {\n  if (aConstant < 40) {\n    return aConstant < 20 ? 1518500249 : 1859775393;\n  } else {\n    if (aConstant < 60) {\n      return aConstant < 20 ? 1518500249 : -1894007588;\n    } else {\n      return aConstant < 20 ? 1518500249 : -899497514;\n    }\n  }\n}\n\nfunction addSafe(alpha: number, beta: number) {\n  const lsw = (alpha & 0xffff) + (beta & 0xffff);\n  const msw = (alpha >> 16) + (beta >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xffff);\n}\n\nfunction bitwiseRotateToLeft(aNumber: number, count: number) {\n  return (aNumber << count) | (aNumber >>> (32 - count));\n}\n\nfunction stringToRawUtf8String(text: string) {\n  let output = \"\";\n  let index = -1;\n  let x;\n  let y;\n  while (++index < text.length) {\n    x = text.charCodeAt(index);\n    y = index + 1 < text.length ? text.charCodeAt(index + 1) : 0;\n    if (0xd800 <= x && x <= 0xdbff && 0xdc00 <= y && y <= 0xdfff) {\n      x = 0x10000 + ((x & 0x03ff) << 10) + (y & 0x03ff);\n      index += 1;\n    }\n    if (x <= 0x7f) {\n      output += String.fromCharCode(x);\n    } else if (x <= 0x7ff) {\n      output += String.fromCharCode(0xc0 | ((x >>> 6) & 0x1f), 0x80 | (x & 0x3f));\n    } else if (x <= 0xffff) {\n      output += String.fromCharCode(0xe0 | ((x >>> 12) & 0x0f), 0x80 | ((x >>> 6) & 0x3f), 0x80 | (x & 0x3f));\n    } else if (x <= 0x1fffff) {\n      output += String.fromCharCode(\n        0xf0 | ((x >>> 18) & 0x07),\n        0x80 | ((x >>> 12) & 0x3f),\n        0x80 | ((x >>> 6) & 0x3f),\n        0x80 | (x & 0x3f),\n      );\n    }\n  }\n  return output;\n}\n\nfunction sha1OfRawString(text: string) {\n  return bigEndianToString(bigEndianToSha1(rawStringToBigEndian(text), text.length * 8));\n}\n\nfunction rawStringToHexString(text: string) {\n  let output = \"\";\n  let hex;\n  for (let index = 0; index < text.length; index += 1) {\n    hex = text.charCodeAt(index);\n    output += \"0123456789abcdef\".charAt((hex >>> 4) & 0x0f) + \"0123456789abcdef\".charAt(hex & 0x0f);\n  }\n  return output;\n}\n\nexport function cryptSha1(text: string): string {\n  // crypto.createHash(\"sha1\").update(text).digest(\"hex\")\n  return rawStringToHexString(sha1OfRawString(stringToRawUtf8String(text)));\n}\n", "import { Table } from \"typeorm\";\n\nexport function extractTableName(tableOrName: Table | string): string {\n  if (typeof tableOrName === \"string\") {\n    return tableOrName;\n  }\n  if (typeof tableOrName === \"object\") {\n    if (\"name\" in tableOrName && typeof tableOrName.name === \"string\" && tableOrName.name.length > 0) {\n      return tableOrName.name;\n    }\n  }\n  return String(tableOrName);\n}\n", "/**\n * @name textCaseCamel\n * @description Converts string into camelCase.\n * @param {string} [text]\n * @param {boolean=} [firstCapital=false]\n * @returns {string}\n */\nexport function textCaseCamel(text: string, firstCapital: boolean = false): string {\n  return text.replace(/^([A-Z])|[\\s-_](\\w)/g, function (match, p1, p2, offset) {\n    if (firstCapital && offset === 0) {\n      return p1;\n    }\n    if (p2) {\n      return p2.toUpperCase();\n    }\n    return p1.toLowerCase();\n  });\n}\n", "/**\n * @name textCaseSnake\n * @description Converts string into snake-case.\n * @param {string} [text]\n * @returns {string}\n */\nexport function textCaseSnake(text: string): string {\n  return text.replace(/(?:([a-z])([A-Z]))|(?:((?!^)[A-Z])([a-z]))/g, \"$1_$3$2$4\").toLowerCase();\n}\n", "import { textCaseCamel } from \"./camel.func\";\nimport { textCaseSnake } from \"./snake.func\";\n\nimport { cryptSha1 } from \"./crypt-sha1.func\";\n\nconst MAX_LENGTH = 64;\n\n/**\n * @name safeConstraint\n * @description Return safe, uncut name for foreign keys, primary keys etc.\n * @param {string} [name]\n * @param {string=} [separatorMinor='_']\n * @param {string=} [separatorMajor='__']\n * @returns {string}\n */\nexport function safeConstraint(name: string, separatorMinor: string = \"_\", separatorMajor: string = \"__\"): string {\n  if (name.length < MAX_LENGTH) {\n    const shortChunks = name.trim().split(separatorMajor);\n    const shortColumns = shortChunks.pop() as string;\n    const shortNamesOriginal = shortColumns.split(separatorMinor);\n    const namesSnakeCase = shortNamesOriginal.map(textCaseSnake);\n    const shortStart = shortChunks.join(separatorMajor);\n    const nameSnake = `${shortStart}${separatorMajor}${namesSnakeCase.join(separatorMinor)}`;\n    if (nameSnake.length < MAX_LENGTH) {\n      return nameSnake;\n    }\n    return name;\n  }\n  const chunks = name.trim().split(separatorMajor);\n  const columns = [...chunks].pop() as string;\n  const namesOriginal = columns.split(separatorMinor);\n  const namesShortSnakeCase = namesOriginal.map(textCaseSnake).map((columnName) => {\n    if (columnName.endsWith(\"_id\") || columnName.endsWith(\"_ref\")) {\n      return columnName.substring(0, columnName.length - 3);\n    }\n    if (columnName.endsWith(\"_uuid\")) {\n      return columnName.substring(0, columnName.length - 5);\n    }\n    return columnName;\n  });\n  const start = chunks.join(separatorMajor);\n  {\n    const snake = `${start}${namesShortSnakeCase.join(separatorMinor)}`;\n    if (snake.length < MAX_LENGTH) {\n      return snake;\n    }\n  }\n  {\n    const camel = `${start}${namesShortSnakeCase\n      .map((toCamelName) => textCaseCamel(toCamelName))\n      .join(separatorMinor)}`;\n    if (camel.length < MAX_LENGTH) {\n      return camel;\n    }\n  }\n  {\n    const shortCamel = `${start}${namesShortSnakeCase\n      .map((columnName) => textCaseCamel(columnName))\n      .join(separatorMinor)}`;\n    if (shortCamel.length < MAX_LENGTH) {\n      return shortCamel;\n    }\n  }\n  {\n    const nameWithSha1 = `${start}${cryptSha1(columns)}`;\n    if (nameWithSha1.length < MAX_LENGTH) {\n      return nameWithSha1;\n    }\n  }\n  {\n    const chunkStart = chunks.shift();\n    const toHash = chunks.join(separatorMajor) + columns;\n    const nameSha1 = `${chunkStart}${separatorMajor}${cryptSha1(toHash)}`;\n    if (nameSha1.length < MAX_LENGTH) {\n      return nameSha1;\n    }\n  }\n  return cryptSha1(name);\n}\n", "export function stripSchema(text: string, strip = true): string {\n  let strippedText = text.trim().normalize(\"NFC\");\n  if (!strippedText.includes(\".\")) {\n    return strippedText;\n  }\n  if (strip && strippedText.startsWith(\"public.\")) {\n    return strippedText.substr(7);\n  }\n  const chunks = strippedText.split(\".\");\n  if (chunks.length !== 2) {\n    return strippedText;\n  }\n  return chunks[1];\n}\n", "import { stripSchema } from \"./strip-schema.func\";\n\nexport function stripPublic(text: string, strip = true): string {\n  let strippedText = text.trim().normalize(\"NFC\");\n  if (!strip) {\n    return strippedText;\n  }\n  return stripSchema(text, true);\n}\n", "import { RelationOptions } from \"typeorm\";\n\nexport const MANY_TO_MANY_OPTION_DEFAULT: RelationOptions = {\n  eager: true,\n} as const;\n\nexport const MANY_TO_ONE_OPTION_DEFAULT: RelationOptions = {\n  eager: true,\n  // lazy: false,\n  onDelete: \"RESTRICT\",\n  onUpdate: \"CASCADE\",\n  // persistence: true,\n} as const;\n\nexport const ONE_TO_ONE_OPTION_DEFAULT: RelationOptions = {\n  eager: true,\n  onDelete: \"CASCADE\",\n  onUpdate: \"CASCADE\",\n} as const;\n", "import { getMetadataArgsStorage } from \"typeorm\";\nimport { CheckMetadataArgs } from \"typeorm/metadata-args/CheckMetadataArgs\";\n\nfunction expressionsToString(expressions: string[]): string {\n  return expressions\n    .map((expression: string) => {\n      expression = expression.trim();\n      do {\n        expression = expression.trim().substring(0, expression.length - 1);\n      } while (expression.endsWith(\";\"));\n      return expression;\n    })\n    .join(\" AND \");\n}\n\nfunction extractArguments(\n  nameOrExpressions:\n    | string\n    | [string, ...string[]]\n    | { expressions: string | [string, ...string[]] }\n    | { expressions: string | [string, ...string[]]; name: string },\n  maybeExpressions?: string | [string, ...string[]],\n): {\n  checkName: string | undefined;\n  expressions: string;\n} {\n  let checkName: string | undefined;\n  let expressions: string | [string, ...string[]] | undefined;\n  if (typeof nameOrExpressions === \"string\" || nameOrExpressions instanceof String) {\n    if (maybeExpressions) {\n      checkName = nameOrExpressions as string;\n      expressions = maybeExpressions; // string | [string, ...string[]]\n    } else {\n      expressions = nameOrExpressions as string;\n    }\n  } else if (Array.isArray(nameOrExpressions)) {\n    expressions = nameOrExpressions;\n  } else if (typeof nameOrExpressions === \"object\") {\n    if (\"name\" in nameOrExpressions) {\n      checkName = nameOrExpressions.name;\n    }\n    if (\"expressions\" in nameOrExpressions) {\n      expressions = nameOrExpressions.expressions;\n    }\n  }\n  if (!expressions || expressions.length === 0) {\n    throw new Error(\n      `Check expressions is required \u279C ${JSON.stringify(nameOrExpressions)}, ${JSON.stringify(maybeExpressions)}`,\n    );\n  }\n  if (!Array.isArray(expressions)) {\n    expressions = [expressions];\n  }\n  expressions = expressionsToString(expressions);\n  return { checkName, expressions };\n}\n\n/**\n * @name Checks\n * @description\n * Creates a database check.\n * Can be used on entity property or on entity.\n * Can create checks with composite columns when used on entity.\n * @param {string|Array.<string>|{expressions:string|Array.<string>}|{expressions:string|Array.<string>,name:string}} [nameOrExpressions]\n * @param {string|Array.<string>=} [maybeExpressions=undefined]\n * @returns {ClassDecorator & PropertyDecorator}\n * @since 0.1.3\n */\nexport function Checks(\n  nameOrExpressions:\n    | string\n    | [string, ...string[]]\n    | { expressions: string | [string, ...string[]] }\n    | { expressions: string | [string, ...string[]]; name: string },\n  maybeExpressions?: string | [string, ...string[]],\n): ClassDecorator & PropertyDecorator {\n  const { checkName, expressions } = extractArguments(nameOrExpressions, maybeExpressions);\n  return function EntityChecksDecorator(\n    clsOrObject:\n      | (<TFunction extends (...args: any[]) => any>(target: TFunction) => TFunction | void)\n      | Record<string, any>,\n    propertyName?: string | symbol,\n  ): void {\n    getMetadataArgsStorage().checks.push({\n      target: propertyName ? clsOrObject.constructor : (clsOrObject as (...args: any[]) => any),\n      name: checkName,\n      expression: expressions,\n    } as CheckMetadataArgs);\n  };\n}\n", "import { Index } from \"typeorm\";\n\nimport { ColumnPrefix } from \"../constant/column.const\";\n\nimport { safeIndex } from \"../util/safe-index.func\";\nimport { safeConstraint } from \"../util/safe-constraint.func\";\n\n/**\n * @name IndexColumns\n * @param {string[]} [fields] List of field names\n * @returns {ClassDecorator & PropertyDecorator}\n * @since 0.1.6\n */\nexport function IndexColumns(fields: string[]): ClassDecorator & PropertyDecorator;\n/**\n * @name IndexColumns\n * @param {string[]} [fields] List of field names\n * @param {boolean|string=} [prefix=false] Add prefix to name\n * @returns {ClassDecorator & PropertyDecorator}\n * @since 0.1.6\n */\nexport function IndexColumns(fields: string[], prefix?: boolean | string): ClassDecorator & PropertyDecorator;\n/**\n * @name IndexColumns\n * @param {string} [name] Column name\n * @param {string[]} [fields] List of field names\n * @returns {ClassDecorator & PropertyDecorator}\n * @since 0.1.6\n */\nexport function IndexColumns(name: string, fields: string[]): ClassDecorator & PropertyDecorator;\n/**\n * @name IndexColumns\n * @param {string} [name] Column name\n * @param {string[]} [fields] List of field names\n * @param {boolean|string=} [prefix=false] Add prefix to name\n * @returns {ClassDecorator & PropertyDecorator}\n * @since 0.1.6\n */\nexport function IndexColumns(\n  name: string,\n  fields: string[],\n  prefix?: boolean | string,\n): ClassDecorator & PropertyDecorator;\n\nexport function IndexColumns(\n  nameOrFields: string | string[],\n  fieldsOrPrefix: string[] | boolean | string = false,\n  prefix: boolean | string = false,\n): ClassDecorator & PropertyDecorator {\n  if (Array.isArray(nameOrFields)) {\n    const fields = nameOrFields; // string[]\n    let passPrefix = undefined;\n    if (prefix === true) {\n      passPrefix = ColumnPrefix.Index;\n    } else if (typeof prefix === \"string\") {\n      passPrefix = prefix;\n    }\n    return Index(safeIndex(fields, passPrefix), fields);\n  } else {\n    const fields = fieldsOrPrefix as string[];\n    let name = nameOrFields; // string\n    if (prefix === true) {\n      name = `${ColumnPrefix.Index}__${name}`;\n    } else if (typeof prefix === \"string\") {\n      name = `${prefix}${name}`;\n    }\n    return Index(safeConstraint(name), fields);\n  }\n}\n", "import { safeConstraint } from \"./safe-constraint.func\";\n\n/**\n * @name safeIndex\n * @description Return safe, uncut name for index key.\n * @param {string[]} [columnNames]\n * @param {string=} [prefix='IDX']\n * @param {string=} [separatorMinor='_']\n * @param {string=} [separatorMajor='__']\n * @returns {string}\n */\nexport function safeIndex(\n  columnNames: string[],\n  prefix: string = \"IDX\",\n  separatorMinor: string = \"_\",\n  separatorMajor: string = \"__\",\n): string {\n  return safeConstraint(\n    `${prefix}${separatorMajor}${columnNames.join(separatorMinor)}`,\n    separatorMinor,\n    separatorMajor,\n  );\n}\n", "import { Unique } from \"typeorm\";\n\nimport { ColumnPrefix } from \"../constant/column.const\";\n\nimport { safeUnique } from \"../util/safe-unique.func\";\nimport { safeConstraint } from \"../util/safe-constraint.func\";\n\n/**\n * @name UniqueColumns\n * @param {string[]} [fields] List of field names\n * @returns {ClassDecorator & PropertyDecorator}\n * @since 0.1.5\n */\nexport function UniqueColumns(fields: string[]): ClassDecorator & PropertyDecorator;\n/**\n * @name UniqueColumns\n * @param {string[]} [fields] List of field names\n * @param {boolean|string=} [prefix=false] Add prefix to name\n * @returns {ClassDecorator & PropertyDecorator}\n * @since 0.1.5\n */\nexport function UniqueColumns(fields: string[], prefix?: boolean | string): ClassDecorator & PropertyDecorator;\n/**\n * @name UniqueColumns\n * @param {string} [name] Column name\n * @param {string[]} [fields] List of field names\n * @returns {ClassDecorator & PropertyDecorator}\n * @since 0.1.5\n */\nexport function UniqueColumns(name: string, fields: string[]): ClassDecorator & PropertyDecorator;\n/**\n * @name UniqueColumns\n * @param {string} [name] Column name\n * @param {string[]} [fields] List of field names\n * @param {boolean|string=} [prefix=false] Add prefix to name\n * @returns {ClassDecorator & PropertyDecorator}\n * @since 0.1.5\n */\nexport function UniqueColumns(\n  name: string,\n  fields: string[],\n  prefix?: boolean | string,\n): ClassDecorator & PropertyDecorator;\n\nexport function UniqueColumns(\n  nameOrFields: string | string[],\n  fieldsOrPrefix: string[] | boolean | string = false,\n  prefix: boolean | string = false,\n): ClassDecorator & PropertyDecorator {\n  if (Array.isArray(nameOrFields)) {\n    const fields = nameOrFields; // string[]\n    let passPrefix = undefined;\n    if (prefix === true) {\n      passPrefix = ColumnPrefix.Unique;\n    } else if (typeof prefix === \"string\") {\n      passPrefix = prefix;\n    }\n    return Unique(safeUnique(fields, passPrefix), fields);\n  } else {\n    const fields = fieldsOrPrefix as string[];\n    let name = nameOrFields; // string\n    if (prefix === true) {\n      name = `${ColumnPrefix.Unique}__${name}`;\n    } else if (typeof prefix === \"string\") {\n      name = `${prefix}${name}`;\n    }\n    return Unique(safeConstraint(name), fields);\n  }\n}\n", "import { safeConstraint } from \"./safe-constraint.func\";\n\n/**\n * @name safeUnique\n * @description Return safe, uncut name for unique key.\n * @param {string[]} [columnNames]\n * @param {string} [prefix='UQ']\n * @param {string} [separatorMinor='_']\n * @param {string} [separatorMajor='__']\n * @returns {string}\n */\nexport function safeUnique(\n  columnNames: string[],\n  prefix: string = \"UQ\",\n  separatorMinor: string = \"_\",\n  separatorMajor: string = \"__\",\n): string {\n  return safeConstraint(\n    `${prefix}${separatorMajor}${columnNames.join(separatorMinor)}`,\n    separatorMinor,\n    separatorMajor,\n  );\n}\n"],
  "mappings": "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",
  "names": []
}
